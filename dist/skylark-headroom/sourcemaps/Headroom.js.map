{"version":3,"sources":["Headroom.js"],"names":["define","features","trackScroll","isBrowser","isSupported","Headroom","elem","options","t","Object","assign","this","classes","tolerance","down","up","initialised","frozen","prototype","constructor","init","cutsTheMustard","addClass","setTimeout","self","scrollTracker","scroller","offset","update","bind","destroy","keys","forEach","removeClass","unpin","hasClass","onUnpin","call","pin","onPin","freeze","unfreeze","top","onTop","notTop","onNotTop","bottom","onBottom","notBottom","onNotBottom","shouldUnpin","details","direction","toleranceExceeded","shouldPin","className","classList","add","apply","split","remove","every","cls","contains","isOutOfBounds","window","pinned","unpinned","initial"],"mappings":"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","file":"../Headroom.js","sourcesContent":["define([\n  \"./features\",\n  \"./trackScroll\"\n],function(features,trackScroll){\n\n\n  var isBrowser = features.isBrowser,\n      isSupported = features.isSupported;\n\n  function normalizeTolerance(t) {\n    return t === Object(t) ? t : { down: t, up: t };\n  }\n\n  /**\n   * UI enhancement for fixed headers.\n   * Hides header when scrolling down\n   * Shows header when scrolling up\n   * @constructor\n   * @param {DOMElement} elem the header element\n   * @param {Object} options options for the widget\n   */\n  function Headroom(elem, options) {\n    options = options || {};\n    Object.assign(this, Headroom.options, options);\n    this.classes = Object.assign({}, Headroom.options.classes, options.classes);\n\n    this.elem = elem;\n    this.tolerance = normalizeTolerance(this.tolerance);\n    this.initialised = false;\n    this.frozen = false;\n  }\n  Headroom.prototype = {\n    constructor: Headroom,\n\n    /**\n     * Start listening to scrolling\n     * @public\n     */\n    init: function() {\n      if (Headroom.cutsTheMustard && !this.initialised) {\n        this.addClass(\"initial\");\n        this.initialised = true;\n\n        // defer event registration to handle browser\n        // potentially restoring previous scroll position\n        setTimeout(\n          function(self) {\n            self.scrollTracker = trackScroll(\n              self.scroller,\n              { offset: self.offset, tolerance: self.tolerance },\n              self.update.bind(self)\n            );\n          },\n          100,\n          this\n        );\n      }\n\n      return this;\n    },\n\n    /**\n     * Destroy the widget, clearing up after itself\n     * @public\n     */\n    destroy: function() {\n      this.initialised = false;\n      Object.keys(this.classes).forEach(this.removeClass, this);\n      this.scrollTracker.destroy();\n    },\n\n    /**\n     * Unpin the element\n     * @public\n     */\n    unpin: function() {\n      if (this.hasClass(\"pinned\") || !this.hasClass(\"unpinned\")) {\n        this.addClass(\"unpinned\");\n        this.removeClass(\"pinned\");\n\n        if (this.onUnpin) {\n          this.onUnpin.call(this);\n        }\n      }\n    },\n\n    /**\n     * Pin the element\n     * @public\n     */\n    pin: function() {\n      if (this.hasClass(\"unpinned\")) {\n        this.addClass(\"pinned\");\n        this.removeClass(\"unpinned\");\n\n        if (this.onPin) {\n          this.onPin.call(this);\n        }\n      }\n    },\n\n    /**\n     * Freezes the current state of the widget\n     * @public\n     */\n    freeze: function() {\n      this.frozen = true;\n      this.addClass(\"frozen\");\n    },\n\n    /**\n     * Re-enables the default behaviour of the widget\n     * @public\n     */\n    unfreeze: function() {\n      this.frozen = false;\n      this.removeClass(\"frozen\");\n    },\n\n    top: function() {\n      if (!this.hasClass(\"top\")) {\n        this.addClass(\"top\");\n        this.removeClass(\"notTop\");\n\n        if (this.onTop) {\n          this.onTop.call(this);\n        }\n      }\n    },\n\n    notTop: function() {\n      if (!this.hasClass(\"notTop\")) {\n        this.addClass(\"notTop\");\n        this.removeClass(\"top\");\n\n        if (this.onNotTop) {\n          this.onNotTop.call(this);\n        }\n      }\n    },\n\n    bottom: function() {\n      if (!this.hasClass(\"bottom\")) {\n        this.addClass(\"bottom\");\n        this.removeClass(\"notBottom\");\n\n        if (this.onBottom) {\n          this.onBottom.call(this);\n        }\n      }\n    },\n\n    notBottom: function() {\n      if (!this.hasClass(\"notBottom\")) {\n        this.addClass(\"notBottom\");\n        this.removeClass(\"bottom\");\n\n        if (this.onNotBottom) {\n          this.onNotBottom.call(this);\n        }\n      }\n    },\n\n    shouldUnpin: function(details) {\n      var scrollingDown = details.direction === \"down\";\n\n      return scrollingDown && !details.top && details.toleranceExceeded;\n    },\n\n    shouldPin: function(details) {\n      var scrollingUp = details.direction === \"up\";\n\n      return (scrollingUp && details.toleranceExceeded) || details.top;\n    },\n\n    addClass: function(className) {\n      this.elem.classList.add.apply(\n        this.elem.classList,\n        this.classes[className].split(\" \")\n      );\n    },\n\n    removeClass: function(className) {\n      this.elem.classList.remove.apply(\n        this.elem.classList,\n        this.classes[className].split(\" \")\n      );\n    },\n\n    hasClass: function(className) {\n      return this.classes[className].split(\" \").every(function(cls) {\n        return this.classList.contains(cls);\n      }, this.elem);\n    },\n\n    update: function(details) {\n      if (details.isOutOfBounds) {\n        // Ignore bouncy scrolling in OSX\n        return;\n      }\n\n      if (this.frozen === true) {\n        return;\n      }\n\n      if (details.top) {\n        this.top();\n      } else {\n        this.notTop();\n      }\n\n      if (details.bottom) {\n        this.bottom();\n      } else {\n        this.notBottom();\n      }\n\n      if (this.shouldUnpin(details)) {\n        this.unpin();\n      } else if (this.shouldPin(details)) {\n        this.pin();\n      }\n    }\n  };\n\n  /**\n   * Default options\n   * @type {Object}\n   */\n  Headroom.options = {\n    tolerance: {\n      up: 0,\n      down: 0\n    },\n    offset: 0,\n    scroller: isBrowser() ? window : null,\n    classes: {\n      frozen: \"headroom--frozen\",\n      pinned: \"headroom--pinned\",\n      unpinned: \"headroom--unpinned\",\n      top: \"headroom--top\",\n      notTop: \"headroom--not-top\",\n      bottom: \"headroom--bottom\",\n      notBottom: \"headroom--not-bottom\",\n      initial: \"headroom\"\n    }\n  };\n\n  Headroom.cutsTheMustard = isSupported();\n\n  return Headroom;\n\n});\n"]}